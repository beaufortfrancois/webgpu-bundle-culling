<!doctype html>

<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>

    <title>RenderBundle Culling - WebGPU</title>
  </head>
  <body>
    <canvas class='webgpu-canvas'></canvas>
    <script type="module">
      import { vec3, vec4, mat4, quat } from 'https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/esm/index.js';
      import { TinyWebGpuDemo } from './common/tiny-webgpu-demo.js'
      import { AttribLocation } from './common/geometry.js'
      import { BoxGeometry, SphereGeometry, CylinderGeometry, ConeGeometry } from './common/shapes.js'

      const tempMat = mat4.create();
      const tempQuat = quat.create();

      const GEOMETRY_SHADER = (geometry) => {
        const layout = geometry.layout;

        return `
          struct VertexIn {
            @builtin(instance_index) instanceIndex : u32,
            @location(${AttribLocation.position}) pos: vec4f,
            @location(${AttribLocation.normal}) norm: vec3f,
            @location(${AttribLocation.texcoord0}) uv0: vec2f,
          }

          struct VertexOut {
            @builtin(position) pos: vec4f,
            @location(0) norm: vec3f,
            @location(1) uv0: vec2f,
          }

          struct Camera {
            projection: mat4x4f,
            view: mat4x4f,
          }
          @group(0) @binding(0) var<uniform> camera: Camera;

          @group(1) @binding(0) var<storage, read> instances: array<mat4x4f>;

          struct Material {
            color: vec4f,
          }
          @group(2) @binding(0) var<uniform> material: Material;

          @vertex
          fn vertexMain(in: VertexIn) -> VertexOut {
            var out: VertexOut;
            let model = instances[in.instanceIndex];
            out.pos = camera.projection * camera.view * model * in.pos;
            out.norm = normalize((camera.view * model * vec4f(in.norm, 0)).xyz);
            out.uv0 = in.uv0;
            return out;
          }

          // Some hardcoded lighting
          const lightDir = vec3f(0.25, 0.5, 1.0);
          const lightColor = vec3f(1, 1, 1);
          const ambientColor = vec3f(0.03, 0.03, 0.03);

          @fragment
          fn fragmentMain(in: VertexOut) -> @location(0) vec4f {
            let baseColor = material.color;
            let N = normalize(in.norm);

            // An extremely simple directional lighting model, just to give our model some shape.
            let L = normalize(lightDir);
            let NDotL = max(dot(N, L), 0.0);
            let surfaceColor = (baseColor.rgb * ambientColor) + (baseColor.rgb * NDotL);

            return vec4(surfaceColor, baseColor.a);
          }
        `;
      }

      const INSTANCES_PER_DRAWABLE = 1000;
      const INSTANCE_ELEMENT_LENGTH = 16;

      const RenderModes = {
        naive: 0,
        instanced: 1,
        renderBundleNaive: 2,
        renderBundleInstanced: 3,
      };

      export class GridDemo extends TinyWebGpuDemo {
        vertexBuffer = null;
        indexBuffer = null;
        instanceBuffer = null;
        instanceArray = null;
        geometries = [];
        materials = [];
        drawables = [];
        pipeline = null;
        renderBundle = null;

        options = {
          animateScene: false,
          renderMode: 1,
        };

        onInit(device) {
          this.camera.distance = 3;

          this.materialBindGroupLayout = this.device.createBindGroupLayout({
            layout: 'Material',
            entries: [{
              binding: 0,
              visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
              buffer: {}
            }]
          });

          const instanceBindGroupLayout = this.device.createBindGroupLayout({
            layout: 'Instance',
            entries: [{
              binding: 0,
              visibility: GPUShaderStage.VERTEX,
              buffer: { type: 'read-only-storage' }
            }]
          });

          // 12 different simple materials
          this.materials.push(this.createMaterialBindGroup(1, 1, 1));
          this.materials.push(this.createMaterialBindGroup(1, 0, 0));
          this.materials.push(this.createMaterialBindGroup(0, 1, 0));
          this.materials.push(this.createMaterialBindGroup(0, 0, 1));
          this.materials.push(this.createMaterialBindGroup(1, 1, 0));
          this.materials.push(this.createMaterialBindGroup(1, 0, 1));
          this.materials.push(this.createMaterialBindGroup(0, 1, 1));

          this.materials.push(this.createMaterialBindGroup(0.5, 0.5, 0.5));
          this.materials.push(this.createMaterialBindGroup(0.5, 0, 0));
          this.materials.push(this.createMaterialBindGroup(0, 0.5, 0));
          this.materials.push(this.createMaterialBindGroup(0, 0, 0.5));
          this.materials.push(this.createMaterialBindGroup(0.5, 0.5, 0));
          this.materials.push(this.createMaterialBindGroup(0.5, 0, 0.5));
          this.materials.push(this.createMaterialBindGroup(0, 0.5, 0.5));


          // Four different geometry types
          this.geometries.push(new BoxGeometry(device));
          this.geometries.push(new SphereGeometry(device));
          this.geometries.push(new CylinderGeometry(device));
          this.geometries.push(new ConeGeometry(device));

          const module = device.createShaderModule({
            label: 'Geometry',
            code: GEOMETRY_SHADER(this.geometries[0]),
          });

          device.createRenderPipelineAsync({
            label: 'Geometry',
            layout: device.createPipelineLayout({ bindGroupLayouts: [
              this.frameBindGroupLayout,
              instanceBindGroupLayout,
              this.materialBindGroupLayout,
            ]}),
            vertex: {
              module,
              entryPoint: 'vertexMain',
              buffers: this.geometries[0].layout.buffers,
            },
            primitive: {
              topology: this.geometries[0].layout.topology,
              stripIndexFormat: this.geometries[0].layout.stripIndexFormat,
            },
            fragment: {
              module,
              entryPoint: 'fragmentMain',
              targets: [{
                format: this.colorFormat,
              }],
            },
            depthStencil: {
              format: this.depthFormat,
              depthWriteEnabled: true,
              depthCompare: 'less-equal',
            },
            multisample: {
              count: this.sampleCount ?? 1
            }
          }).then((pipeline) => {
            this.pipeline = pipeline;
          });

          // Build a bunch of instances with every geometry and material combination
          function createInstanceData() {
            const scale = Math.random() + 0.5;
            const axis = vec3.fromValues(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1);
            vec3.normalize(axis, axis);

            return {
              pos: vec3.fromValues(
                (Math.random() * 2 - 1) * 100,
                (Math.random() * 2 - 1) * 100,
                (Math.random() * 2 - 1) * 100),
              scale: vec3.fromValues(scale, scale, scale),
              axis: axis,
              rotationSpeed: Math.random() * 2 - 1,
            };
          }

          let instanceCount = 0;
          for (const material of this.materials) {
            for (const geometry of this.geometries) {
              let instances = [];

              for (let i = 0; i < INSTANCES_PER_DRAWABLE; ++i) {
                instances.push(createInstanceData());
              }

              // Sort the instances so the closest ones to the center are drawn
              // first to improve overdraw
              instances.sort((a, b) => vec3.length(a.pos) - vec3.length(b.pos));

              this.drawables.push({
                material,
                geometry,
                instances,
                first: instanceCount,
                count: INSTANCES_PER_DRAWABLE,
              });

              instanceCount += INSTANCES_PER_DRAWABLE;
            }
          }

          this.instanceArray = new Float32Array(instanceCount * INSTANCE_ELEMENT_LENGTH);

          this.instanceBuffer = this.device.createBuffer({
            label: 'Instance',
            size: this.instanceArray.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
          });

          this.instanceBindGroup = this.device.createBindGroup({
            label: 'Instance',
            layout: instanceBindGroupLayout,
            entries: [{
              binding: 0,
              resource: { buffer: this.instanceBuffer }
            }],
          });

          this.updateInstanceBuffer(performance.now());

          this.pane.addBlade({
            label: 'render mode',
            view: 'list',
            options: RenderModes,
            value: this.options.renderMode
          }).on('change', (ev) => {
            this.options.renderMode = ev.value;
            this.renderBundle = null;
          });
          this.pane.addBinding(this.options, 'animateScene');

          this.pane.addButton({
            title: 'ViewSource',
          }).on('click', () => { window.location = 'https://github.com/toji/webgpu-bundle-culling' });
        }

        createMaterialBindGroup(r, g, b) {
          const materialBuffer = this.device.createBuffer({
            label: `Material (${r}, ${g}, ${b})`,
            size: Float32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM,
            mappedAtCreation: true,
          });
          const materialArray = new Float32Array(materialBuffer.getMappedRange());
          materialArray[0] = r;
          materialArray[1] = g;
          materialArray[2] = b;
          materialArray[3] = 1;
          materialBuffer.unmap();

          return this.device.createBindGroup({
            label: `Material (${r}, ${g}, ${b})`,
            layout: this.materialBindGroupLayout,
            entries: [{
              binding: 0,
              resource: { buffer: materialBuffer }
            }],
          });
        }

        updateShapeInstances(shape, timestamp) {
          for (let i = 0; i < shape.count; ++i) {
            const instance = shape.instances[i];
            quat.setAxisAngle(tempQuat, instance.axis, timestamp * instance.rotationSpeed * 0.001);
            mat4.fromRotationTranslationScale(tempMat, tempQuat, instance.pos, instance.scale);

            const arrayOffset = (shape.first + i) * INSTANCE_ELEMENT_LENGTH;
            this.instanceArray.set(tempMat, arrayOffset);
            this.instanceArray.set(instance.color, arrayOffset + 16);
          }
        }

        updateInstanceBuffer(timestamp) {
          for (const drawable of this.drawables) {
            for (let i = 0; i < drawable.count; ++i) {
              const instance = drawable.instances[i];
              quat.setAxisAngle(tempQuat, instance.axis, timestamp * instance.rotationSpeed * 0.001);
              mat4.fromRotationTranslationScale(tempMat, tempQuat, instance.pos, instance.scale);

              const arrayOffset = (drawable.first + i) * INSTANCE_ELEMENT_LENGTH;
              this.instanceArray.set(tempMat, arrayOffset);
            }
          }

          this.device.queue.writeBuffer(this.instanceBuffer, 0, this.instanceArray);
        }

        drawScene(renderEncoder, instanced) {
          renderEncoder.setBindGroup(0, this.frameBindGroup);
          renderEncoder.setBindGroup(1, this.instanceBindGroup);
          renderEncoder.setPipeline(this.pipeline);

          for (const drawable of this.drawables) {
            renderEncoder.setBindGroup(2, drawable.material);
            drawable.geometry.setBuffers(renderEncoder);

            if (instanced) {
              drawable.geometry.draw(renderEncoder, drawable.count, drawable.first);
            } else {
              for (let i = drawable.first; i < drawable.first + drawable.count; ++i) {
                drawable.geometry.draw(renderEncoder, 1, i);
              }
            }
          }
        }

        getRenderBundle() {
          if (!this.renderBundle) {
            const encoder = this.device.createRenderBundleEncoder({
              colorFormats: [ this.colorFormat ],
              depthStencilFormat: this.depthFormat,
              sampleCount: this.sampleCount
            });

            this.drawScene(encoder, this.options.renderMode == RenderModes.renderBundleInstanced);

            this.renderBundle = encoder.finish();
          }
          return this.renderBundle;
        }

        onFrame(device, context, timestamp) {
          const commandEncoder = device.createCommandEncoder();
          const renderPass = commandEncoder.beginRenderPass(this.defaultRenderPassDescriptor);

          if (this.options.animateScene) {
            this.updateInstanceBuffer(timestamp);
          }

          if (this.pipeline) {
            switch (this.options.renderMode) {
              case RenderModes.naive:
                this.drawScene(renderPass, false);
                break;
              case RenderModes.instanced:
                this.drawScene(renderPass, true);
                break;
              case RenderModes.renderBundleNaive:
              case RenderModes.renderBundleInstanced:
                renderPass.executeBundles([this.getRenderBundle()]);
                break;
            }
          }

          renderPass.end();

          device.queue.submit([commandEncoder.finish()]);
        }
      }

      const demo = new GridDemo();
    </script>
  </body>
</html>