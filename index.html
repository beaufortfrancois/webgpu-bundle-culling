<!doctype html>

<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>

    <title>RenderBundle Culling - WebGPU</title>
  </head>
  <body>
    <canvas class='webgpu-canvas'></canvas>
    <script type="module">
      import { vec3, vec4, mat4, quat } from 'https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/esm/index.js';
      import { TinyWebGpuDemo } from './common/tiny-webgpu-demo.js'
      import { AttribLocation } from './common/geometry.js'
      import { BoxGeometry, SphereGeometry, CylinderGeometry, ConeGeometry } from './common/shapes.js'

      const tempMat = mat4.create();
      const tempQuat = quat.create();

      const GEOMETRY_SHADER = (geometry) => {
        const layout = geometry.layout;

        return `
          struct VertexIn {
            @builtin(instance_index) instanceIndex : u32,
            @location(${AttribLocation.position}) pos: vec4f,
            @location(${AttribLocation.normal}) norm: vec3f,
            @location(${AttribLocation.texcoord0}) uv0: vec2f,
          }

          struct VertexOut {
            @builtin(position) pos: vec4f,
            @location(0) norm: vec3f,
            @location(1) uv0: vec2f,
            @location(2) color: vec4f,
          }

          struct Camera {
            projection: mat4x4f,
            view: mat4x4f,
          }
          @group(0) @binding(0) var<uniform> camera: Camera;

          struct Instance {
            model: mat4x4f,
            color: vec4f,
          }
          @group(1) @binding(0) var<storage, read> instances: array<Instance>;

          @vertex
          fn vertexMain(in: VertexIn) -> VertexOut {
            var out: VertexOut;
            let model = instances[in.instanceIndex].model;
            out.pos = camera.projection * camera.view * model * in.pos;
            out.norm = normalize((camera.view * model * vec4f(in.norm, 0)).xyz);
            out.uv0 = in.uv0;
            out.color = instances[in.instanceIndex].color;
            return out;
          }

          // Some hardcoded lighting
          const lightDir = vec3f(0.25, 0.5, 1.0);
          const lightColor = vec3f(1, 1, 1);
          const ambientColor = vec3f(0.03, 0.03, 0.03);

          @fragment
          fn fragmentMain(in: VertexOut) -> @location(0) vec4f {
            let baseColor = in.color;
            let N = normalize(in.norm);

            // An extremely simple directional lighting model, just to give our model some shape.
            let L = normalize(lightDir);
            let NDotL = max(dot(N, L), 0.0);
            let surfaceColor = (baseColor.rgb * ambientColor) + (baseColor.rgb * NDotL);

            return vec4(surfaceColor, baseColor.a);
          }
        `;
      }

      const MAX_INSTANCE_COUNT = 100000;
      const INSTANCE_ELEMENT_LENGTH = 20;
      const INSTANCE_BYTE_LENGTH = Float32Array.BYTES_PER_ELEMENT * INSTANCE_ELEMENT_LENGTH;

      const RenderModes = {
        naive: 0,
        instanced: 1,
        renderBundleNaive: 2,
        renderBundleInstanced: 3,
      };

      export class GridDemo extends TinyWebGpuDemo {
        vertexBuffer = null;
        indexBuffer = null;
        instanceBuffer = null;
        bindGroup = null;
        pipeline = null;
        renderBundle = null;

        options = {
          animateScene: false,
          renderMode: 1,
        };

        cubes = {
          first: 0,
          count: 0,
          instances: [],
        };
        spheres = {
          first: 0,
          count: 0,
          instances: [],
        };
        cylinders = {
          first: 0,
          count: 0,
          instances: [],
        };
        cones = {
          first: 0,
          count: 0,
          instances: [],
        };

        instanceArray = new Float32Array(MAX_INSTANCE_COUNT * INSTANCE_ELEMENT_LENGTH);

        onInit(device) {
          this.camera.distance = 3;

          this.cubeGeometry = new BoxGeometry(device, {x: 0});
          this.sphereGeometry = new SphereGeometry(device, {x: 0});
          this.cylinderGeometry = new CylinderGeometry(device, {x:0});
          this.coneGeometry = new ConeGeometry(device, {x:0});

          const module = device.createShaderModule({
            label: 'Geometry Module',
            code: GEOMETRY_SHADER(this.cubeGeometry),
          });

          const instanceBindGroupLayout = device.createBindGroupLayout({
            layout: 'Geometry Bind Group Layout',
            entries: [{
              binding: 0,
              visibility: GPUShaderStage.VERTEX,
              buffer: { type: 'read-only-storage' }
            }]
          });

          device.createRenderPipelineAsync({
            label: 'Geometry Pipeline',
            layout: device.createPipelineLayout({ bindGroupLayouts: [
              this.frameBindGroupLayout,
              instanceBindGroupLayout,
            ]}),
            vertex: {
              module,
              entryPoint: 'vertexMain',
              buffers: this.cubeGeometry.layout.buffers,
            },
            primitive: {
              topology: this.cubeGeometry.layout.topology,
              stripIndexFormat: this.cubeGeometry.layout.stripIndexFormat,
            },
            fragment: {
              module,
              entryPoint: 'fragmentMain',
              targets: [{
                format: this.colorFormat,
              }],
            },
            depthStencil: {
              format: this.depthFormat,
              depthWriteEnabled: true,
              depthCompare: 'less-equal',
            },
            multisample: {
              count: this.sampleCount ?? 1
            }
          }).then((pipeline) => {
            this.pipeline = pipeline;
          });

          this.instanceBuffer = this.device.createBuffer({
            label: 'Instance',
            size: MAX_INSTANCE_COUNT * INSTANCE_BYTE_LENGTH,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
          });

          this.instanceBindGroup = this.device.createBindGroup({
            label: 'Instance',
            layout: instanceBindGroupLayout,
            entries: [{
              binding: 0,
              resource: { buffer: this.instanceBuffer }
            }],
          });

          function createInstanceData() {
            const scale = Math.random() + 0.5;
            const axis = vec3.fromValues(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1);
            vec3.normalize(axis, axis);

            return {
              pos: vec3.fromValues(
                (Math.random() * 2 - 1) * 100,
                (Math.random() * 2 - 1) * 100,
                (Math.random() * 2 - 1) * 100),
              scale: vec3.fromValues(scale, scale, scale),
              axis: axis,
              rotationSpeed: Math.random() * 2 - 1,
              color: vec4.fromValues(
                Math.random() * 0.66 + 0.33,
                Math.random() * 0.66 + 0.33,
                Math.random() * 0.66 + 0.33,
                1)
            };
          }

          // Setup the initial instance data
          this.cubes.first = 0;
          this.cubes.count = MAX_INSTANCE_COUNT / 4;
          this.spheres.first = this.cubes.first + this.cubes.count;
          this.spheres.count = MAX_INSTANCE_COUNT / 4;
          this.cylinders.first = this.spheres.first + this.spheres.count;
          this.cylinders.count = MAX_INSTANCE_COUNT / 4;
          this.cones.first = this.cylinders.first + this.cylinders.count;
          this.cones.count = MAX_INSTANCE_COUNT / 4;

          for (let i = 0; i < MAX_INSTANCE_COUNT / 4; ++i) {
            this.cubes.instances[i] = createInstanceData();
            this.spheres.instances[i] = createInstanceData();
            this.cylinders.instances[i] = createInstanceData();
            this.cones.instances[i] = createInstanceData();
          }

          this.updateInstanceBuffer(performance.now());

          this.pane.addBlade({
            label: 'render mode',
            view: 'list',
            options: RenderModes,
            value: this.options.renderMode
          }).on('change', (ev) => {
            this.options.renderMode = ev.value;
            this.renderBundle = null;
          });
          this.pane.addBinding(this.options, 'animateScene');

          this.pane.addButton({
            title: 'ViewSource',
          }).on('click', () => { window.location = 'https://github.com/toji/webgpu-bundle-culling' });
        }

        updateShapeInstances(shape, timestamp) {
          for (let i = 0; i < shape.count; ++i) {
            const instance = shape.instances[i];
            quat.setAxisAngle(tempQuat, instance.axis, timestamp * instance.rotationSpeed * 0.001);
            mat4.fromRotationTranslationScale(tempMat, tempQuat, instance.pos, instance.scale);

            const arrayOffset = (shape.first + i) * INSTANCE_ELEMENT_LENGTH;
            this.instanceArray.set(tempMat, arrayOffset);
            this.instanceArray.set(instance.color, arrayOffset + 16);
          }
        }

        updateInstanceBuffer(timestamp) {
          this.updateShapeInstances(this.cubes, timestamp);
          this.updateShapeInstances(this.spheres, timestamp);
          this.updateShapeInstances(this.cylinders, timestamp);
          this.updateShapeInstances(this.cones, timestamp);

          this.device.queue.writeBuffer(this.instanceBuffer, 0, this.instanceArray);
        }

        drawScene(renderEncoder, instanced) {
          renderEncoder.setBindGroup(0, this.frameBindGroup);
          renderEncoder.setBindGroup(1, this.instanceBindGroup);
          renderEncoder.setPipeline(this.pipeline);

          if (instanced) {
            this.cubeGeometry.setBuffers(renderEncoder);
            this.cubeGeometry.draw(renderEncoder, this.cubes.count, this.cubes.first);

            this.sphereGeometry.setBuffers(renderEncoder);
            this.sphereGeometry.draw(renderEncoder, this.spheres.count, this.spheres.first);

            this.cylinderGeometry.setBuffers(renderEncoder);
            this.cylinderGeometry.draw(renderEncoder, this.cylinders.count, this.cylinders.first);

            this.coneGeometry.setBuffers(renderEncoder);
            this.coneGeometry.draw(renderEncoder, this.cones.count, this.cones.first);
          } else {
            // This route makes a separate draw call for every single shape in the scene.
            // THIS IS NOT A BEST PRACTICE! Only shown here for educational purposes. Use instancing
            // where you can.
            const drawShapes = (shape, geometry) => {
              geometry.setBuffers(renderEncoder);
              for (let i = shape.first; i < shape.first + shape.count; ++i) {
                geometry.draw(renderEncoder, 1, i);
              }
            }

            drawShapes(this.cubes, this.cubeGeometry);
            drawShapes(this.spheres, this.sphereGeometry);
            drawShapes(this.cylinders, this.cylinderGeometry);
            drawShapes(this.cones, this.coneGeometry);
          }
        }

        getRenderBundle() {
          if (!this.renderBundle) {
            const encoder = this.device.createRenderBundleEncoder({
              colorFormats: [ this.colorFormat ],
              depthStencilFormat: this.depthFormat,
              sampleCount: this.sampleCount
            });

            this.drawScene(encoder, this.options.renderMode == RenderModes.renderBundleInstanced);

            this.renderBundle = encoder.finish();
          }
          return this.renderBundle;
        }

        onFrame(device, context, timestamp) {
          const commandEncoder = device.createCommandEncoder();
          const renderPass = commandEncoder.beginRenderPass(this.defaultRenderPassDescriptor);

          if (this.options.animateScene) {
            this.updateInstanceBuffer(timestamp);
          }

          if (this.pipeline) {
            switch (this.options.renderMode) {
              case RenderModes.naive:
                this.drawScene(renderPass, false);
                break;
              case RenderModes.instanced:
                this.drawScene(renderPass, true);
                break;
              case RenderModes.renderBundleNaive:
              case RenderModes.renderBundleInstanced:
                renderPass.executeBundles([this.getRenderBundle()]);
                break;
            }
          }

          renderPass.end();

          device.queue.submit([commandEncoder.finish()]);
        }
      }

      const demo = new GridDemo();
    </script>
  </body>
</html>